var documenterSearchIndex = {"docs":
[{"location":"frompackage/custom_settings/#Customize-Macro-Settings","page":"Custom Settings","title":"Customize Macro Settings","text":"The macro also allows to override default settings similar to how one skip lines in the package, using a custom @settings block as:\n\n@fromparent begin\n    @settings setting1 = val1 setting2 = val2\n    import *\nend\n\nor alternatively: \n\n@fromparent begin\n    @settings begin\n        setting1 = val1\n        setting2 = val2\n    end\n    import *\nend\n\nOnly assignments are supported inside the @settings block and only primitive values can be used as val, i.e. anything that is parsed as an Expr as macro argument is not a valid val.\n\nThese are the supported settings:","category":"section"},{"location":"frompackage/custom_settings/#SHOULD_PREPEND_LOAD_PATH","page":"Custom Settings","title":"SHOULD_PREPEND_LOAD_PATH","text":"Bool value that defaults to false. \n\nThis specifies whether the active environment added to the LOAD_PATH by the macro should go to the end or to the front of the LOAD_PATH. In some cases it can be useful to have the custom environment at the beginning of the LOAD_PATH for the purpose of locating packages.","category":"section"},{"location":"other_functions/#Other-Functions","page":"Other Exports","title":"Other Functions","text":"This package also exports some additional convenience macros for simplifying package development aided by Pluto notebooks.\n\nAdditionally, the non-exported function PlutoDevMacros.hide_this_log can be used for sending javascript code through logs to Pluto and hide the corresponding log from view (without stopping the javascript code to execute)","category":"section"},{"location":"other_functions/#Utilities-Macros","page":"Other Exports","title":"Utilities Macros","text":"","category":"section"},{"location":"other_functions/#Utilities-Functions","page":"Other Exports","title":"Utilities Functions","text":"","category":"section"},{"location":"other_functions/#PlutoDevMacros.@addmethod","page":"Other Exports","title":"PlutoDevMacros.@addmethod","text":"@addmethod func(args...;kwargs...) = body\n@addmethod function func(args...;kwargs...) \n\tbody\nend\n\nThis simple macro modifies a function definition expression (only when called from a Pluto notebook) to prepend the name of the module defining the function (here called DefiningModule) to the method definition.\n\nSo the code\n\n@addmethod func(args...;kwargs...) = something\n\nis simply translated to\n\nDefiningModule.func(args...;kwargs...) = something\n\nwhen called from a Pluto notebook, and to:\n\nfunc(args...;kwargs...) = something\n\nwhen called outside of Pluto.\n\nThis is useful to avoid multiple definition errors inside Pluto but has the caveat that defining a method with @addmethod does not trigger a reactive run of all cells that call the modified function. This also mean that when removing the cell with the @addmethod call, the actual method added to the DefiningModule will not be automatically erased by Pluto and will still accessible until it is not overwritten with another method with the same signature. \n\nThis is easy to fix in the case of adding methods to modules loaded with @frompackage/@fromparent as reloading the module is sufficient to remove the hanging method.\n\nSee this video for an example:\n\n(Image: Link to Video)\n\nSee also: @frompackage, @fromparent\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@only_in_nb","page":"Other Exports","title":"PlutoDevMacros.@only_in_nb","text":"only_in_nb(ex)\n\nExecutes the expression ex only if the macro is called from a running Pluto instance and ran directly from the source notebook file.\n\nThis is more strict than PlutoHooks.@skip_as_script as including a notebook with @skip_as_script ex from another notebook would still execute ex.\n@only_in_nb ex instead only evaluates ex if the calling notebook is the original source notebook file.\n\nSee also: @only_out_nb. PlutoHooks.@skip_as_script.\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@only_out_nb","page":"Other Exports","title":"PlutoDevMacros.@only_out_nb","text":"only_out_nb(ex)\n\nOpposite of @only_in_nb\n\nSee also: @only_in_nb. PlutoHooks.@only_as_script.\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@current_pluto_cell_id","page":"Other Exports","title":"PlutoDevMacros.@current_pluto_cell_id","text":"@current_pluto_cell_id()\n\nReturns the cell_id (as a string) of the cell where the macro is called. If not ran from within the pluto notebook containing the call, returns an empty string\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@current_pluto_notebook_file","page":"Other Exports","title":"PlutoDevMacros.@current_pluto_notebook_file","text":"@current_pluto_notebook_file()\n\nReturns the path of the notebook file of the cell where the macro is called. If not ran from within the pluto notebook containing the call, returns an empty string\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.hide_this_log","page":"Other Exports","title":"PlutoDevMacros.hide_this_log","text":"hide_this_log(html_content::AbstractString = \"\")\nhide_this_log(html::Docs.HTML)\n\nSimple function that returns a Docs.HTML object which when sent to Pluto logs with e.g. @info (or any other loggin macro), will hide the log from view.\n\nIt is mostly intended to send some javascript to the logs for execution but avoid having an empty log box hanging around below the cell. The output of this function contains a script which will hide the specific log that contains it, and if no other logs are present, will also hide the log container in Pluto.\n\nThe function also optionally accept some content that will be inserted just before the script for hiding the log. The custom input can be provided as an AbstractString, or directly as an HTML object of type Docs.HTML, in which case it will simply extract the HTML contents as String from the contents field. The provided content will be directly interpreted as HTML, meaning that any script will have to be surrounded by <script> tags.\n\nThis function is used inside PlutoDevMacros to create the reload @fromparent button also via logs for redundancy.\n\nExample\n\nSuppose you are inside a Pluto notebook and you want to execute some custom javascript from a cell, but for some reason you don't want to have the javascript to be the final output of your cell. You can exploit logs for this (assuming you didn't disable logging for the cell in question).\n\nThe following snippet can be inserted in a cell to send a custom message on the javascript developer console while still having a non-javascript cell output.\n\njulia_output = let\n    @info PlutoDevMacros.hide_this_log(html\"<script>console.log('message')</script>\")\n    3\nend\n\nWhich will correctly send the message to the console even if the cell output is not the javascript script: (Image: hide_this_log example gif)\n\n\n\n\n\n","category":"function"},{"location":"frompackage/package_extensions/#Package-Extensions","page":"Package Extensions","title":"Package Extensions","text":"The @frompackage macro supports package extensions defined within the packages loaded by the macro within the import_block\n\nWe specify two possible types of extensions within the context of @frompackage:\n\nDirect Extensions: These are extensions that are defined directly within the local target package loaded by the macro\nIndirect Extensions: These are extensions that are not defined by the target package directly, but by one of its dependencies.","category":"section"},{"location":"frompackage/package_extensions/#Direct-Extensions","page":"Package Extensions","title":"Direct Extensions","text":"An example of a scenario with Direct Extensions is the one of the TestDirectExtension package found in the test/TestDirectExtension folder and whose Project.toml is replicated below:\n\nname = \"TestDirectExtension\"\nuuid = \"f446dfe5-66ce-4684-9abf-53561df9f9a0\"\nauthors = [\"Alberto Mengali <disberd@gmail.com>\"]\nversion = \"0.1.0\"\n\n[deps]\nRevise = \"295af30f-e4ad-537b-8983-00126c2a3abe\"\n\n[weakdeps]\nPlutoPlotly = \"8e989ff0-3d88-8e9f-f020-2b208a939ff0\"\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[extensions]\nPlutoPlotlyExt = \"PlutoPlotly\"\nMagic = \"Example\"\n\nWe can see that this package defines two extensions PlutoPlotlyExt and Magic that depend on the PlutoPlotly and Example packages respectively.\n\nWhen the TestDirectExtension module is loaded within a Pluto notebook using the @frompackage or @fromparent macro, the module is not associated to a package UUID so julia does not know that the Magic extension has to be loaded whenever the Example package is loaded into the notebook.\n\nTo still support loading the extension code in this situation, the macro will eval the Magic module definition within the TestDirectExtension module if the Example package is defined within the notebook environment. This allows prototyping and testing package extensions during their development exploiting the @frompackage macro.\n\nCheck the relevant example notebook located at test/TestDirectExtension/test_extension.jl for more clarity.","category":"section"},{"location":"frompackage/package_extensions/#Indirect-Extensions","page":"Package Extensions","title":"Indirect Extensions","text":"Indirect extensions are mostly handled correctly by julia directly, but some issues may arise when a package added to the notebook environment triggers the load of an extension of a package loaded as a direct dependency within the import_block.\n\nIf the notebook package triggering the extension is loaded after the direct dependency has already been loaded by the @frompackage macro, an extension compilation error is generated because the direct dependency is not in the LOAD_PATH (See the Use with PlutoPkg section)\n\nThe way to solve this issue is to simply reload the local code by using the re-executing the cell containing the macro call. This will trigger a call to Base.retry_load_extensions.","category":"section"},{"location":"frompackage/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"The main functionality provided by PlutoDevMacros is the possibility of loading local packages within a Pluto notebook without requiring to activate a local environment (and thus deactivate the Pluto package manager).\n\nThis functionality is implemented inside the FromPackage submodule of PlutoDevMacros and accessed throught the @fromparent or @frompackage macros.\n\nnote: Note\nBoth @fromparent and @frompackage are exported by PlutoDevMacros itself without requiring to explicitly use FromPackage.\n\nWhile the @fromparent macro was initially developed in order to facilitate creating Julia packages using Pluto notebooks as building blocks, in its current implementation it helps a lot with prototyping and testing during local package development, even when creating normal packages not relying on Pluto notebooks as building blocks.\n\nThis macro allows in fact to load the module of a local package within a running Pluto notebook and permits to easily reload the local code upon request similar to a Revise-based workflow but with a few notable advantages:\n\nPackage code can be re-evaluated correctly without requiring a julia restart even when re-defining structs or constants\nLocal code reload, triggered manually via a floating button in the Pluto notebook, automatically triggers execution of all dependent cells, simplifying the process of testing changes of code on specific runtime paths\nPossibilty of adding packages to the notebook environment which are not dependencies of the local package, very useful for testing plotting or benchmarking of the local package code without having to put the related packages in either the global or package-local environment\nSupport for the package extensions functionality added in julia 1.9, which together with the point on notebook environment above simplify the testing and development of extensions on the local package under development.\n\nMore details on the synthax and functionality of these macros is given in the following sections.","category":"section"},{"location":"frompackage/introduction/#PlutoDevMacros.FromPackage.@frompackage","page":"Introduction","title":"PlutoDevMacros.FromPackage.@frompackage","text":"@frompackage target import_block\n\nThis macro takes a local Package (derived from the target path, which can be an AbstractString or a @raw_str), loads it as a submodule of the current Pluto workspace and then process the various import/using statements inside import_block to extract varables/functions from the local Package into the notebook workspace.\n\nIts main use is allowing to load a local package under development within a running Pluto notebook in order to facilitate prototyping and testing.\n\nThe following julia code inside a Pluto notebook cell:\n\n@frompackage local_package_path begin\n\timport ^: *\n\tusing >.LocalDependency\nend\n\ntakes the main module definition code for the package located at local_package_path, creates the corresponding module in the notebook workspace and imports all of the names defined within (That is what the import ^:* statement does).\n\nAdditionally, it loads the package called LocalDependency (must be a dependency of the local package) as if the using LocalDependency code was used within the notebook, but without adding LocalDependency to the notebook environment.\n\nSee the package documentation for more details.\n\nSee also: @fromparent\n\n\n\n\n\n","category":"macro"},{"location":"frompackage/introduction/#PlutoDevMacros.FromPackage.@fromparent","page":"Introduction","title":"PlutoDevMacros.FromPackage.@fromparent","text":"This macro is equivalent to @frompackage but assumes the calling file as the target argument. So the code \n\n@fromparent import_block\n\nis equivalent to\n\n@frompackage @__FILE__ import_block\n\nRefer to the @frompackage docstring and the package documentation for understanding its use. See also: @addmethod\n\n\n\n\n\n","category":"macro"},{"location":"frompackage/basic_use/#Basic-Use","page":"Basic Use","title":"Basic Use","text":"@fromparent import_block\n@frompackage target import_block\n\nThe @frompackage macro takes a local Package (derived from the target path), loads it as a submodule of the current Pluto workspace and then process the various import/using statements inside import_block to extract varables/functions from the local Package into the notebook workspace.\n\nnote: Note\n@fromparent is simply a convenience synthax that uses the calling notebook file as target. More details on how the target path is processed are given below.\n\nDue to the equivalence in functionality between @frompackage and @fromparent, the rest of the documentation will only refer to @frompackage for convenience.\n\nWhen changes to the code of the local Package are made, the cell containing the call to @frompackage can be re-executed to reload the most recent version of the module. Thanks to Pluto's reactivity, this will automatically trigger re-execution of all cells that use functionality defined in the local package loaded by the macro.\n\nWhen testing functionalities of the local package using statements in the notebook cells, this reactivity simplifies the workflow as one does not need to manually re-run tests. At the same time, re-loading the full package module at each statement (similar to what Revise does) would most likely generate a significant overhead.\n\nFor this reason the reload of local code is only triggered manually within @frompackage and happens only when manually re-running the cell containing the macro call. This process is simplified by the reload button explained below.","category":"section"},{"location":"frompackage/basic_use/#target-path","page":"Basic Use","title":"target path","text":"The first argument to @frompackage (target) has to be an AbstractString (or a @raw_str) containing the path (either absolute or relative to the file calling the macro) that points to a local Package (the path can be to any file or subfolder within the Package folder).\n\nThe main module of the package identified by the target path will be used as the module to process and load within the calling notebook","category":"section"},{"location":"frompackage/basic_use/#import_block","page":"Basic Use","title":"import_block","text":"The second argument to the macro is supposed to be either a single using/import statement, or multiple statements wrapped inside a begin...end block.\n\nThese statements are used to select which parts of the loaded Package module have to be evaluated and which of its variables have to be imported within the notebook scope. Most of these import statements are only relevant when called within Pluto, so @frompackage simply avoid loading the target Package and deletes these import statements in most cases when called oustide of Pluto. There is a specific type of import statement (relative import) that is relevant and applicable also outside of Pluto, so this kind of statement is maintained in the macro output even outside of Pluto.\n\nThe macro respects the differentiation between using and import as in normal Julia, so statements containing using Module without any variable name specifier will import all the exported names of Module.","category":"section"},{"location":"frompackage/basic_use/#Reload-Button","page":"Basic Use","title":"Reload Button","text":"When called within Pluto, the @frompackage macro also creates a convenient button that can be used to re-execute the cell calling the macro to reload the Package code due to a change in the source files.\n\nThis button can also be used to quickly navigate to the position of the cell containing the macro by using Ctrl+Click.\nThe reload button will change appearance (getting a red border) when the macrocall incur in a runtime error either due to incorrect import statement (like if a relative import is used without a proper target) or due to an error encountered when loading the package code.\n\nHere is a short video showing the reload button. The window on the left has opened the specific_imports1.jl notebook, while the one on the right has the specific_imports2.jl one. \n\nBoth are included in the TestPackage using for tests and defined in test/TestPackage/src/TestPackage.jl\n\n<video controls=true>\n<source src=\"https://user-images.githubusercontent.com/12846528/236453634-c95aa7b2-61eb-492f-85f5-6539bbb714d5.mp4\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"frompackage/import_statements/#Supported-import-statements","page":"Supported import statements","title":"Supported import statements","text":"The macro supports 4 different types of import statements:\n\nRelative Imports \nImports from the Package module\nImport from the Parent module (or submodule)\nImport from the Package dependencies (direct or indirect).\n\nwhich are explained in more details in their respective section\n\nAll of them also allow the following (catch-all) notation import Module: *, which imports within the notebook all the variables that are created or imported within Module. This is useful when one wants to quickly import all the names defined in Module for testing without requiring to either:\n\nexport all names in the definition of Module\nexplicitly import each name using the import Module: name1, name2, ... synthax\n\nEach import statement can only contain one module, so statements like *import Module1, Module2 are not supported. In case multiple imports are *needed, use multiple statements within a begin...end block.","category":"section"},{"location":"frompackage/import_statements/#Relative-Imports","page":"Supported import statements","title":"Relative Imports","text":"Relative imports are the ones where the module name starts with a dot (.). These are mostly relevant when the loaded module contains multiple submodules.\nRelative import statements are also produced when the macro is called from Pluto.\n\nnote: Note\nRelative imports are mostly useful when creating packages with notebooks as building blocks (i.e. notebooks that are included within the local package module)\n\nWhile catch-all notation is supported also with relative imports (e.g. import ..SiblingModule: *), the extraction of all the names from the desired relative module requires loading and inspecting the full Package module and is thus only functional inside of Pluto.\nA relative-import with catch-all notation is deleted when @frompackage is called outside of Pluto.","category":"section"},{"location":"frompackage/import_statements/#Imports-from-Package-module","page":"Supported import statements","title":"Imports from Package module","text":"These are all the import statements that have the name PackageModule or ^ as the first identifier, e.g.: \n\nusing PackageModule.SubModule \nimport PackageModule: varname \nimport PackageModule.SubModule.SubSubModule: * \n\nThese statements are processed by the macro and transformed so that PackageModule actually points to the module that was loaded by the macro.\n\nThe alternative notation ^ can also be used to represent the PackageModule, so one can write the two expressions below interchangeably\n\n@fromparent import PackageModule: var_name\n@fromparent import ^: var_name\n\nThis is to avoid triggering the Pkg statusmark within Pluto which always appears when a valid name of a package is typed (^ is not valid so it doesn't create the status mark). See image below: (Image: image)","category":"section"},{"location":"frompackage/import_statements/#Imports-from-Parent-module-(or-submodule)","page":"Supported import statements","title":"Imports from Parent module (or submodule)","text":"These statements are similar to the previous (imports from Package module) ones, with two main difference:\n\nThey only work if the target file is actually a file that is included in the loaded Package, giving an error otherwise\nParentModule does not point to the loaded Package, but the module that contains the line that calls include(target).\n\nIf target  is loaded from the Package main module, and not from one of its submodules, then ParentModule will point to the same module as PackageModule.","category":"section"},{"location":"frompackage/import_statements/#Catch-All","page":"Supported import statements","title":"Catch-All","text":"A special kind parent module import is:\n\nimport *\n\nwhich is equivalent to:\n\nimport ParentModule: * if the target file provided to @frompackage/@fromparent is a file included in the target Package. \nThis tries to reproduce within the namespace of the calling notebook, the namespace that would be visible by the notebook file when it is loaded as part of the Package module outside of Pluto.\nimport PackageModule: * if the target file provided to @frompackage/@fromparent is not a file included in the target Package. ","category":"section"},{"location":"frompackage/import_statements/#Imports-from-Package-dependencies","page":"Supported import statements","title":"Imports from Package dependencies","text":"It is possible to to import direct (or indirect) dependencies of the target Package from within the @frompackage macro. Direct dependencies are the ones directy listed within the [deps] section of the Project.toml. Indirect dependencies are instead all the packages within the Package's Manifest.toml which are not direct dependencies. To import a package dependency from the @frompackage macro, one must prepend the package name with >., so for example if one wants to load the BenchmarkTools package from the macro, assuming that it is indeed a dependency of the target package, one can do:\n\n@frompackage target begin\n    using >.BenchmarkTools\nend\n\nThis modification is necessary when trying to use @frompackage in combination with the Pluto PkgManager, as explained in Issue 10.\n\nThese kind of statements (import/using from Dependencies) are also supported both inside and outside Pluto. Outside of Pluto, only direct dependencies are supported (as that is how julia works) which means that the example code above will effectively translate to using BenchmarkTools both inside and outside of Pluto if BenchmarkTools is a direct dependency.\n\nnote: Note\nThese kind of statements can not be used in combination with the catch-all imported name (*).\n\nImports from package dependencies are useful when trying to combine @frompackage with the integrated Pluto PkgManager. In this case, is preferable to keep in the Pluto notebook environment just the packages that are not also part of the target/loaded Package environment, and load the eventual packages that are also in the environment of the loaded Package directly from within the @frompackage import_block.\n\nDoing so minimizes the risk of having issues caused by versions collision between dependencies that are shared both by the notebook environment and the loaded Package environment. Combining the use of @frompackage with the Pluto PkgManager is a very experimental feature that comes with significant caveats.  Please read the related section at the end of this README","category":"section"},{"location":"frompackage/import_statements/#Re-export-using-names-with-Catch-All","page":"Supported import statements","title":"Re-export using names with Catch-All","text":"Prior to version v0.7.3 of PlutoDevMacros, the catch-all import would not allow to automatically import names in the scope of the parent/package module that were added via using statements. See Issue 11 for more details on the reasons.\n\nThis meant that to effectively have access to all of the names in the parent/package scope, the statement @fromparent import * would not be sufficient. If for example you had using Base64 at the top of your module, to effectively have access to also the names of the Base64 stdlib, you would have to call the macro as follows:\n\n@fromparent begin\n    import *\n    using >.Base64\nend\n\nSince v0.8.0 of PlutoDevMacros, the automatic inclusion of names exposed via using statements is the default behavior when doing catch-all imports.\n\nnote: Note\nSince this behavior now brings by default many more names into scope, a new functionality in 0.8 is a check that names in the target packages do not clash with existing names in the Pluto module that is calling @frompackage. Once a clash is identified (i.e. two different objects with the same name are defined in both the Pluto module and the target package), the specific clashed name will not be brought into scope by @frompackage and a warning will be issued. \n\nYou can see this warning for example in the test notebook at test/TestUsingNames/test_notebook2.jl, where the name :clash_name is explicitly given to different values both in the target and calling modules, and results in the following warning: (Image: Warning Example Image)\n\nIf one wants to revert back to the previous version where only names effectively defined within the target module (or explicitly imported with import OtherPackage: x) would be brought into the Pluto module's scope, it is sufficient to prepend the @exclude_using macro to the catch-all import statement like so:\n\n@fromparent @exclude_using import *\n\nThis statement can be used alone or coupled with other valid import statements within a begin ... end block.","category":"section"},{"location":"#PlutoDevMacros","page":"Home","title":"PlutoDevMacros","text":"Documentation for PlutoDevMacros.\n\nThis is a package containing macros/functions to help develop Packages using Pluto notebooks testing/prototyping aids.\n\nThe major feature contribution of this package is the @fromparent macro, which allows to load a local package in Pluto and have its code re-parsed and updated upon manual re-run of the cell containing the macro call.","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"To load the parent package of a notebook, i.e. the package that is in the same directory or parent directory of a notebook file use:\n\nusing PlutoDevMacros\n\n@fromparent import *\n\nIn Pluto you will then see a Reload button which can be used to reload the module on any changes.\n\nFor more information please refer to the explanations linked below.","category":"section"},{"location":"#@frompackage/@fromparent","page":"Home","title":"@frompackage/@fromparent","text":"Pages = [\n    \"frompackage/introduction.md\",\n    \"frompackage/basic_use.md\",\n    \"frompackage/import_statements.md\",\n    \"frompackage/skipping_parts.md\",\n    \"frompackage/use_with_plutopkg.md\",\n    \"frompackage/package_extensions.md\",\n]\nDepth = 1","category":"section"},{"location":"frompackage/skipping_parts/#Skipping-Package-Parts","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The macro also allows to specify parts of the source code of the target Package that have to be skipped when loading it within Pluto. This is achieved by adding a statement inside the import_block like the following:\n\n@skiplines lines\n\nThe @skiplines macro is not defined within the package, it's just processed during the parsing of the @frompackage macro.\n\nlines is expected to either be a single String, or a group of Strings within a begin ... end block. Each string represent a part of a file that has to be skipped, with the following formats being supported:\n\nfilpeath:::firstline-lastline: This specifies that all the lines between firstline and lastline (extrema included) in the file present at filepath must be skipped when loading the Package module\nfilepath:::line: Like 1. but a single line is skipped\nfilepath: Like 1. but the full file located at filepath is ignored when loading the module \nline: Ignores line number line in the Package entry point (i.e. the file at src/PackageName.jl in the folder of PackageName)\nfirstline-lastline: Like 4., but ignores a range of lines.\n\nIn all of the examples above filepath can be provided as either an absolute path, or as a relative path starting from the src subfolder of the Package folder\n\nThe functionality of skipping lines is only used when @frompackage is called inside Pluto.  When calling the macro from outside of Pluto, the eventual statement with @skiplines is discarded.","category":"section"},{"location":"frompackage/skipping_parts/#Example","page":"Skipping Package Parts","title":"Example","text":"For an example consider the source file of the TestPackage module defined at test/TestPackage/src/TestPackage.jl, whose contents are shown below:\n\n(Image: image)\n\nThe notebook called out_notebook.jl located in the main folder of TestPackage gives an example of how to use the new functionality.\n\nThe following call to @fromparent is used to import the TestPackage in the notebook's workspace while removing some of the code that is present in the original source of TestPackage:\n\n@fromparent begin\n\timport TestPackage\n\t@skiplines begin\n\t\t\"11\" # Skip line 11 in the main file TestPackage.jl.\n\t\t\"test_macro2.jl\" # This skips the whole file test_macro2.jl\n\t\t\"22-23\" # This skips from line 21 to 22 in the main file, including extrema.\n\t\t\"test_macro1.jl:::28-10000\" # This skips parts of test_macro1.jl\n\tend\nend\n\nThe output of the notebook is also pasted here for reference:\n\n(Image: image)","category":"section"},{"location":"frompackage/use_with_plutopkg/#Use-with-PlutoPkg","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"The macro evaluates the code of the local target package within the Pluto notebook workspace. For this to work, the notebook needs to have access to all the packages that are loaded within the target package.\n\nNormally, this is achieved by either:\n\nAdding the dependencies directly to the notebook environment\nActivating the environment of the local package within the notebook\n\nThe first option risk polluting the notebook environment with a lot of packages that are not directly used within the notebook, while the second option deactivate the integrate PlutoPkg which handles package dependencies.\n\nTo address these issues, the macro currently adds the target package environment to the LOAD_PATH during package code evaluation in the notebook workspace.\n\nThis approach gives the flexibility of loading arbitrary local package code without requiring to modify the notebook environment itself.\n\nnote: Note\nFor this to work, the environment of the local target package needs to be instantiated. The macro will actually errors if this is not the case.\n\nThe macro tries to catch all possible exceptions that are thrown either during macro compilation or during the resulting expression evaluation (using a try catch) to correctly clean LOAD_PATH after the macro is executed.\n\nThis approach may cause issues in case the notebook and the package environment share some dependencies at different version. In this case, the one that was loaded first is the actual version used within the notebook (and within the Package module when loaded in the notebook).\n\nThe macro adds the local package environment at the second position in the LOAD_PATH (so after the notebook environment). This should minimize the potential issues as the notebook environment is parsed first to find the packages. This does not prevent the case when a package (for example DataFrames) that is only used by the loaded package, is also added to the notebook after the target Package has been loaded.  In this case, the version of DataFrames used by the notebook will be the version loaded by Package, and not the one installed in the notebook environment. Upon restarting the notebook, the situation will flip. Since now DataFrames is in the notebook environment, the notebook version will be loaded both in the notebook and in the Package module, potentially causing issues with the PackageCode if it was depending on a different version of DataFrames.\n\nDue to the issues just mentioned, use the macro knowing that it might break if you want to use the Pluto PkgManager without manually adding all depending packages to the notebook environment.","category":"section"}]
}
