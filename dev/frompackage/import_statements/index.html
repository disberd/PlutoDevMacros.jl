<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supported import statements · PlutoDevMacros.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PlutoDevMacros.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">@frompackage/@fromparent</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../basic_use/">Basic Use</a></li><li class="is-active"><a class="tocitem" href>Supported import statements</a><ul class="internal"><li><a class="tocitem" href="#Relative-Imports"><span>Relative Imports</span></a></li><li><a class="tocitem" href="#Imports-from-Package-module"><span>Imports from Package module</span></a></li><li><a class="tocitem" href="#Imports-from-Parent-module-(or-submodule)"><span>Imports from Parent module (or submodule)</span></a></li><li><a class="tocitem" href="#Imports-from-Package-dependencies"><span>Imports from Package dependencies</span></a></li><li><a class="tocitem" href="#Re-export-using-names-with-Catch-All"><span>Re-export <code>using</code> names with Catch-All</span></a></li></ul></li><li><a class="tocitem" href="../skipping_parts/">Skipping Package Parts</a></li><li><a class="tocitem" href="../use_with_plutopkg/">Use with PlutoPkg</a></li><li><a class="tocitem" href="../package_extensions/">Package Extensions</a></li><li><a class="tocitem" href="../custom_settings/">Custom Settings</a></li></ul></li><li><a class="tocitem" href="../../other_functions/">Other Exports</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">@frompackage/@fromparent</a></li><li class="is-active"><a href>Supported import statements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Supported import statements</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/disberd/PlutoDevMacros.jl/blob/master/docs/src/frompackage/import_statements.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Supported-import-statements"><a class="docs-heading-anchor" href="#Supported-import-statements">Supported import statements</a><a id="Supported-import-statements-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-import-statements" title="Permalink"></a></h1><p>The macro supports 4 different types of import statements:</p><ul><li>Relative Imports </li><li>Imports from the Package module</li><li>Import from the Parent module (or submodule)</li><li>Import from the Package dependencies (direct or indirect).</li></ul><p>which are explained in more details in their respective section</p><p>All of them also allow the following (<em>catch-all</em>) notation <code>import Module: *</code>, which imports within the notebook all the variables that are created or imported within <code>Module</code>. This is useful when one wants to quickly import all the names defined in <code>Module</code> for testing without requiring to either:</p><ul><li>export all names in the definition of <code>Module</code></li><li>explicitly import each name using the <code>import Module: name1, name2, ...</code> synthax</li></ul><p><strong>Each import statement can only contain one module</strong>, so statements like *<code>import Module1, Module2</code> are not supported. In case multiple imports are *needed, use multiple statements within a <code>begin...end</code> block.</p><h2 id="Relative-Imports"><a class="docs-heading-anchor" href="#Relative-Imports">Relative Imports</a><a id="Relative-Imports-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-Imports" title="Permalink"></a></h2><p>Relative imports are the ones where the module name starts with a dot (.). These are mostly relevant when the loaded module contains multiple submodules.<br/><strong>Relative import statements are also produced when the macro is called from Pluto</strong>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Relative imports are mostly useful when creating packages with notebooks as building blocks (i.e. notebooks that are <em>included</em> within the local package module)<br/><br/>While <em>catch-all</em> notation is supported also with relative imports (e.g. <code>import ..SiblingModule: *</code>), the extraction of all the names from the desired relative module requires loading and inspecting the full Package module and is thus only functional inside of Pluto.<br/><strong>A relative-import with catch-all notation is deleted when @frompackage is called outside of Pluto</strong>.</p></div></div><h2 id="Imports-from-Package-module"><a class="docs-heading-anchor" href="#Imports-from-Package-module">Imports from Package module</a><a id="Imports-from-Package-module-1"></a><a class="docs-heading-anchor-permalink" href="#Imports-from-Package-module" title="Permalink"></a></h2><p>These are all the import statements that have the name <code>PackageModule</code> or <code>^</code> as the first identifier, e.g.: </p><ul><li><code>using PackageModule.SubModule</code> </li><li><code>import PackageModule: varname</code> </li><li><code>import PackageModule.SubModule.SubSubModule: *</code> </li></ul><p>These statements are processed by the macro and transformed so that <code>PackageModule</code> actually points to the module that was loaded by the macro.</p><p>The alternative notation <code>^</code> can also be used to represent the <code>PackageModule</code>, so one can write the two expressions below interchangeably</p><pre><code class="language-julia hljs">@fromparent import PackageModule: var_name
@fromparent import ^: var_name</code></pre><p>This is to avoid triggering the Pkg statusmark within Pluto which always appears when a valid name of a package is typed (<code>^</code> is not valid so it doesn&#39;t create the status mark). See image below: <img src="https://user-images.githubusercontent.com/12846528/236888015-454183e6-44c1-4cd0-b9f8-9faf67aa0da6.png" alt="image"/></p><h2 id="Imports-from-Parent-module-(or-submodule)"><a class="docs-heading-anchor" href="#Imports-from-Parent-module-(or-submodule)">Imports from Parent module (or submodule)</a><a id="Imports-from-Parent-module-(or-submodule)-1"></a><a class="docs-heading-anchor-permalink" href="#Imports-from-Parent-module-(or-submodule)" title="Permalink"></a></h2><p>These statements are similar to the previous (imports from Package module) ones, with two main difference:</p><ul><li>They only work if the <code>target</code> file is actually a file that is included in the loaded Package, giving an error otherwise</li><li><code>ParentModule</code> does not point to the loaded Package, but the module that contains the line that calls <code>include(target)</code>.</li></ul><p>If <code>target</code>  is loaded from the Package main module, and not from one of its submodules, then <code>ParentModule</code> will point to the same module as <code>PackageModule</code>.</p><h3 id="Catch-All"><a class="docs-heading-anchor" href="#Catch-All">Catch-All</a><a id="Catch-All-1"></a><a class="docs-heading-anchor-permalink" href="#Catch-All" title="Permalink"></a></h3><p>A special kind parent module import is:</p><pre><code class="language-julia hljs">import *</code></pre><p>which is equivalent to:</p><ul><li><code>import ParentModule: *</code> if the <code>target</code> file provided to <code>@frompackage</code>/<code>@fromparent</code> <strong>is</strong> a file <em>included</em> in the target Package. <ul><li>This tries to reproduce within the namespace of the calling notebook, the namespace that would be visible by the notebook file when it is loaded as part of the Package module outside of Pluto.</li></ul></li><li><code>import PackageModule: *</code> if the <code>target</code> file provided to <code>@frompackage</code>/<code>@fromparent</code> <strong>is not</strong> a file <em>included</em> in the target Package. </li></ul><h2 id="Imports-from-Package-dependencies"><a class="docs-heading-anchor" href="#Imports-from-Package-dependencies">Imports from Package dependencies</a><a id="Imports-from-Package-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Imports-from-Package-dependencies" title="Permalink"></a></h2><p>It is possible to to import direct (or indirect) dependencies of the target Package from within the <code>@frompackage</code> macro. Direct dependencies are the ones directy listed within the <code>[deps]</code> section of the <code>Project.toml</code>. Indirect dependencies are instead all the packages within the Package&#39;s <code>Manifest.toml</code> which are not direct dependencies. To import a package dependency from the <code>@frompackage</code> macro, one must prepend the package name with <code>&gt;.</code>, so for example if one wants to load the <code>BenchmarkTools</code> package from the macro, assuming that it is indeed a dependency of the target package, one can do:</p><pre><code class="language-julia hljs">@frompackage target begin
    using &gt;.BenchmarkTools
end</code></pre><p>This modification is necessary when trying to use <code>@frompackage</code> in combination with the Pluto PkgManager, as explained in <a href="https://github.com/disberd/PlutoDevMacros.jl/pull/10">Issue 10</a>.</p><p>These kind of statements (import/using from Dependencies) are also supported both inside and outside Pluto. <strong>Outside of Pluto, only direct dependencies are supported</strong> (as that is how julia works) which means that the example code above will effectively translate to <code>using BenchmarkTools</code> both inside and outside of Pluto if BenchmarkTools is a direct dependency.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These kind of statements can not be used in combination with the <code>catch-all</code> imported name (*).<br/><br/>Imports from package dependencies are useful when trying to combine <code>@frompackage</code> with the integrated Pluto PkgManager. In this case, is preferable to keep in the Pluto notebook environment just the packages that are not also part of the target/loaded Package environment, and load the eventual packages that are also in the environment of the loaded Package directly from within the <code>@frompackage</code> <code>import_block</code>.<br/><br/>Doing so minimizes the risk of having issues caused by versions collision between dependencies that are shared both by the notebook environment and the loaded Package environment. Combining the use of <code>@frompackage</code> with the Pluto PkgManager is a very experimental feature that comes with significant caveats.  Please read the <a href="#use-of-fromparentfrompackage-with-pluto-pkgmanager">related section</a> at the end of this README</p></div></div><h2 id="Re-export-using-names-with-Catch-All"><a class="docs-heading-anchor" href="#Re-export-using-names-with-Catch-All">Re-export <code>using</code> names with Catch-All</a><a id="Re-export-using-names-with-Catch-All-1"></a><a class="docs-heading-anchor-permalink" href="#Re-export-using-names-with-Catch-All" title="Permalink"></a></h2><p>Prior to version v0.7.3 of PlutoDevMacros, the catch-all import would not allow to automatically import names in the scope of the parent/package module that were added via <code>using</code> statements. See <a href="https://github.com/disberd/PlutoDevMacros.jl/issues/11">Issue 11</a> for more details on the reasons.</p><p>This meant that to effectively have access to all of the names in the parent/package scope, the statement <code>@fromparent import *</code> would not be sufficient. If for example you had <code>using Base64</code> at the top of your module, to effectively have access to also the names of the <code>Base64</code> stdlib, you would have to call the macro as follows:</p><pre><code class="language-julia hljs">@fromparent begin
    import *
    using &gt;.Base64
end</code></pre><p>Since v0.8.0 of PlutoDevMacros, the automatic inclusion of names exposed via <code>using</code> statements is the default behavior when doing <code>catch-all</code> imports.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since this behavior now brings by default many more names into scope, a new functionality in 0.8 is a check that names in the target packages do not clash with existing names in the Pluto module that is calling <code>@frompackage</code>. Once a clash is identified (i.e. two different objects with the same name are defined in both the Pluto module and the target package), the specific clashed name will not be brought into scope by <code>@frompackage</code> and a warning will be issued. <br/><br/>You can see this warning for example in the test notebook at <a href="https://github.com/disberd/PlutoDevMacros.jl/tree/master/test/TestUsingNames/test_notebook2.jl">test/TestUsingNames/test_notebook2.jl</a>, where the name <code>:clash_name</code> is explicitly given to different values both in the target and calling modules, and results in the following warning: <img src="https://github.com/disberd/PlutoDevMacros.jl/assets/12846528/c32e53bd-3607-483c-9330-dad66a9b6a4a" alt="Warning Example Image"/></p></div></div><p>If one wants to revert back to the previous version where only names effectively defined within the target module (or explicitly imported with <code>import OtherPackage: x</code>) would be brought into the Pluto module&#39;s scope, it is sufficient to prepend the <code>@exclude_using</code> macro to the <em>catch-all</em> import statement like so:</p><pre><code class="language-julia hljs">@fromparent @exclude_using import *</code></pre><p>This statement can be used alone or coupled with other valid import statements within a <code>begin ... end</code> block.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basic_use/">« Basic Use</a><a class="docs-footer-nextpage" href="../skipping_parts/">Skipping Package Parts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 2 June 2024 17:17">Sunday 2 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
