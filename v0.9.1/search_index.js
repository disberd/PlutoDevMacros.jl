var documenterSearchIndex = {"docs":
[{"location":"frompackage/custom_settings/#Customize-Macro-Settings","page":"Custom Settings","title":"Customize Macro Settings","text":"","category":"section"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"The macro also allows to override default settings similar to how one skip lines in the package, using a custom @settings block as:","category":"page"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"@fromparent begin\n    @settings setting1 = val1 setting2 = val2\n    import *\nend","category":"page"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"or alternatively: ","category":"page"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"@fromparent begin\n    @settings begin\n        setting1 = val1\n        setting2 = val2\n    end\n    import *\nend","category":"page"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"Only assignments are supported inside the @settings block and only primitive values can be used as val, i.e. anything that is parsed as an Expr as macro argument is not a valid val.","category":"page"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"These are the supported settings:","category":"page"},{"location":"frompackage/custom_settings/#SHOULD_PREPEND_LOAD_PATH","page":"Custom Settings","title":"SHOULD_PREPEND_LOAD_PATH","text":"","category":"section"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"Bool value that defaults to false. ","category":"page"},{"location":"frompackage/custom_settings/","page":"Custom Settings","title":"Custom Settings","text":"This specifies whether the active environment added to the LOAD_PATH by the macro should go to the end or to the front of the LOAD_PATH. In some cases it can be useful to have the custom environment at the beginning of the LOAD_PATH for the purpose of locating packages.","category":"page"},{"location":"other_functions/#Other-Functions","page":"Other Exports","title":"Other Functions","text":"","category":"section"},{"location":"other_functions/","page":"Other Exports","title":"Other Exports","text":"This package also exports some additional convenience macros for simplifying package development aided by Pluto notebooks.","category":"page"},{"location":"other_functions/","page":"Other Exports","title":"Other Exports","text":"Additionally, the non-exported function PlutoDevMacros.hide_this_log can be used for sending javascript code through logs to Pluto and hide the corresponding log from view (without stopping the javascript code to execute)","category":"page"},{"location":"other_functions/#Utilities-Macros","page":"Other Exports","title":"Utilities Macros","text":"","category":"section"},{"location":"other_functions/","page":"Other Exports","title":"Other Exports","text":"@addmethod\n@only_in_nb\n@only_out_nb\n@current_pluto_cell_id\n@current_pluto_notebook_file","category":"page"},{"location":"other_functions/#PlutoDevMacros.@addmethod","page":"Other Exports","title":"PlutoDevMacros.@addmethod","text":"@addmethod func(args...;kwargs...) = body\n@addmethod function func(args...;kwargs...) \n\tbody\nend\n\nThis simple macro modifies a function definition expression (only when called from a Pluto notebook) to prepend the name of the module defining the function (here called DefiningModule) to the method definition.\n\nSo the code\n\n@addmethod func(args...;kwargs...) = something\n\nis simply translated to\n\nDefiningModule.func(args...;kwargs...) = something\n\nwhen called from a Pluto notebook, and to:\n\nfunc(args...;kwargs...) = something\n\nwhen called outside of Pluto.\n\nThis is useful to avoid multiple definition errors inside Pluto but has the caveat that defining a method with @addmethod does not trigger a reactive run of all cells that call the modified function. This also mean that when removing the cell with the @addmethod call, the actual method added to the DefiningModule will not be automatically erased by Pluto and will still accessible until it is not overwritten with another method with the same signature. \n\nThis is easy to fix in the case of adding methods to modules loaded with @frompackage/@fromparent as reloading the module is sufficient to remove the hanging method.\n\nSee this video for an example:\n\n(Image: Link to Video)\n\nSee also: @frompackage, @fromparent\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@only_in_nb","page":"Other Exports","title":"PlutoDevMacros.@only_in_nb","text":"only_in_nb(ex)\n\nExecutes the expression ex only if the macro is called from a running Pluto instance and ran directly from the source notebook file.\n\nThis is more strict than PlutoHooks.@skip_as_script as including a notebook with @skip_as_script ex from another notebook would still execute ex.\n@only_in_nb ex instead only evaluates ex if the calling notebook is the original source notebook file.\n\nSee also: @only_out_nb. PlutoHooks.@skip_as_script.\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@only_out_nb","page":"Other Exports","title":"PlutoDevMacros.@only_out_nb","text":"only_out_nb(ex)\n\nOpposite of @only_in_nb\n\nSee also: @only_in_nb. PlutoHooks.@only_as_script.\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@current_pluto_cell_id","page":"Other Exports","title":"PlutoDevMacros.@current_pluto_cell_id","text":"@current_pluto_cell_id()\n\nReturns the cell_id (as a string) of the cell where the macro is called. If not ran from within the pluto notebook containing the call, returns an empty string\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#PlutoDevMacros.@current_pluto_notebook_file","page":"Other Exports","title":"PlutoDevMacros.@current_pluto_notebook_file","text":"@current_pluto_notebook_file()\n\nReturns the path of the notebook file of the cell where the macro is called. If not ran from within the pluto notebook containing the call, returns an empty string\n\n\n\n\n\n","category":"macro"},{"location":"other_functions/#Utilities-Functions","page":"Other Exports","title":"Utilities Functions","text":"","category":"section"},{"location":"other_functions/","page":"Other Exports","title":"Other Exports","text":"PlutoDevMacros.hide_this_log","category":"page"},{"location":"other_functions/#PlutoDevMacros.hide_this_log","page":"Other Exports","title":"PlutoDevMacros.hide_this_log","text":"hide_this_log(html_content::AbstractString = \"\")\nhide_this_log(html::Docs.HTML)\n\nSimple function that returns a Docs.HTML object which when sent to Pluto logs with e.g. @info (or any other loggin macro), will hide the log from view.\n\nIt is mostly intended to send some javascript to the logs for execution but avoid having an empty log box hanging around below the cell. The output of this function contains a script which will hide the specific log that contains it, and if no other logs are present, will also hide the log container in Pluto.\n\nThe function also optionally accept some content that will be inserted just before the script for hiding the log. The custom input can be provided as an AbstractString, or directly as an HTML object of type Docs.HTML, in which case it will simply extract the HTML contents as String from the contents field. The provided content will be directly interpreted as HTML, meaning that any script will have to be surrounded by <script> tags.\n\nThis function is used inside PlutoDevMacros to create the reload @fromparent button also via logs for redundancy.\n\nExample\n\nSuppose you are inside a Pluto notebook and you want to execute some custom javascript from a cell, but for some reason you don't want to have the javascript to be the final output of your cell. You can exploit logs for this (assuming you didn't disable logging for the cell in question).\n\nThe following snippet can be inserted in a cell to send a custom message on the javascript developer console while still having a non-javascript cell output.\n\njulia_output = let\n    @info PlutoDevMacros.hide_this_log(html\"<script>console.log('message')</script>\")\n    3\nend\n\nWhich will correctly send the message to the console even if the cell output is not the javascript script: (Image: hide_this_log example gif)\n\n\n\n\n\n","category":"function"},{"location":"frompackage/package_extensions/#Package-Extensions","page":"Package Extensions","title":"Package Extensions","text":"","category":"section"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"The @frompackage macro supports package extensions defined within the packages loaded by the macro within the import_block","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"We specify two possible types of extensions within the context of @frompackage:","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"Direct Extensions: These are extensions that are defined directly within the local target package loaded by the macro\nIndirect Extensions: These are extensions that are not defined by the target package directly, but by one of its dependencies.","category":"page"},{"location":"frompackage/package_extensions/#Direct-Extensions","page":"Package Extensions","title":"Direct Extensions","text":"","category":"section"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"An example of a scenario with Direct Extensions is the one of the TestDirectExtension package found in the test/TestDirectExtension folder and whose Project.toml is replicated below:","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"name = \"TestDirectExtension\"\nuuid = \"f446dfe5-66ce-4684-9abf-53561df9f9a0\"\nauthors = [\"Alberto Mengali <disberd@gmail.com>\"]\nversion = \"0.1.0\"\n\n[deps]\nRevise = \"295af30f-e4ad-537b-8983-00126c2a3abe\"\n\n[weakdeps]\nPlutoPlotly = \"8e989ff0-3d88-8e9f-f020-2b208a939ff0\"\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[extensions]\nPlutoPlotlyExt = \"PlutoPlotly\"\nMagic = \"Example\"","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"We can see that this package defines two extensions PlutoPlotlyExt and Magic that depend on the PlutoPlotly and Example packages respectively.","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"When the TestDirectExtension module is loaded within a Pluto notebook using the @frompackage or @fromparent macro, the module is not associated to a package UUID so julia does not know that the Magic extension has to be loaded whenever the Example package is loaded into the notebook.","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"To still support loading the extension code in this situation, the macro will eval the Magic module definition within the TestDirectExtension module if the Example package is defined within the notebook environment. This allows prototyping and testing package extensions during their development exploiting the @frompackage macro.","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"Check the relevant example notebook located at test/TestDirectExtension/test_extension.jl for more clarity.","category":"page"},{"location":"frompackage/package_extensions/#Indirect-Extensions","page":"Package Extensions","title":"Indirect Extensions","text":"","category":"section"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"Indirect extensions are mostly handled correctly by julia directly, but some issues may arise when a package added to the notebook environment triggers the load of an extension of a package loaded as a direct dependency within the import_block.","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"If the notebook package triggering the extension is loaded after the direct dependency has already been loaded by the @frompackage macro, an extension compilation error is generated because the direct dependency is not in the LOAD_PATH (See the Use with PlutoPkg section)","category":"page"},{"location":"frompackage/package_extensions/","page":"Package Extensions","title":"Package Extensions","text":"The way to solve this issue is to simply reload the local code by using the re-executing the cell containing the macro call. This will trigger a call to Base.retry_load_extensions.","category":"page"},{"location":"frompackage/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"The main functionality provided by PlutoDevMacros is the possibility of loading local packages within a Pluto notebook without requiring to activate a local environment (and thus deactivate the Pluto package manager).","category":"page"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"This functionality is implemented inside the FromPackage submodule of PlutoDevMacros and accessed throught the @fromparent or @frompackage macros.","category":"page"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"note: Note\nBoth @fromparent and @frompackage are exported by PlutoDevMacros itself without requiring to explicitly use FromPackage.","category":"page"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"While the @fromparent macro was initially developed in order to facilitate creating Julia packages using Pluto notebooks as building blocks, in its current implementation it helps a lot with prototyping and testing during local package development, even when creating normal packages not relying on Pluto notebooks as building blocks.","category":"page"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"This macro allows in fact to load the module of a local package within a running Pluto notebook and permits to easily reload the local code upon request similar to a Revise-based workflow but with a few notable advantages:","category":"page"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"Package code can be re-evaluated correctly without requiring a julia restart even when re-defining structs or constants\nLocal code reload, triggered manually via a floating button in the Pluto notebook, automatically triggers execution of all dependent cells, simplifying the process of testing changes of code on specific runtime paths\nPossibilty of adding packages to the notebook environment which are not dependencies of the local package, very useful for testing plotting or benchmarking of the local package code without having to put the related packages in either the global or package-local environment\nSupport for the package extensions functionality added in julia 1.9, which together with the point on notebook environment above simplify the testing and development of extensions on the local package under development.","category":"page"},{"location":"frompackage/introduction/","page":"Introduction","title":"Introduction","text":"More details on the synthax and functionality of these macros is given in the following sections.","category":"page"},{"location":"frompackage/basic_use/#Basic-Use","page":"Basic Use","title":"Basic Use","text":"","category":"section"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"@fromparent import_block\n@frompackage target import_block","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"The @frompackage macro takes a local Package (derived from the target path), loads it as a submodule of the current Pluto workspace and then process the various import/using statements inside import_block to extract varables/functions from the local Package into the notebook workspace.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"note: Note\n@fromparent is simply a convenience synthax that uses the calling notebook file as target. More details on how the target path is processed are given below.\n\nDue to the equivalence in functionality between @frompackage and @fromparent, the rest of the documentation will only refer to @frompackage for convenience.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"When changes to the code of the local Package are made, the cell containing the call to @frompackage can be re-executed to reload the most recent version of the module. Thanks to Pluto's reactivity, this will automatically trigger re-execution of all cells that use functionality defined in the local package loaded by the macro.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"When testing functionalities of the local package using statements in the notebook cells, this reactivity simplifies the workflow as one does not need to manually re-run tests. At the same time, re-loading the full package module at each statement (similar to what Revise does) would most likely generate a significant overhead.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"For this reason the reload of local code is only triggered manually within @frompackage and happens only when manually re-running the cell containing the macro call. This process is simplified by the reload button explained below.","category":"page"},{"location":"frompackage/basic_use/#target-path","page":"Basic Use","title":"target path","text":"","category":"section"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"The first argument to @frompackage (target) has to be an AbstractString (or a @raw_str) containing the path (either absolute or relative to the file calling the macro) that points to a local Package (the path can be to any file or subfolder within the Package folder).","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"The main module of the package identified by the target path will be used as the module to process and load within the calling notebook","category":"page"},{"location":"frompackage/basic_use/#import_block","page":"Basic Use","title":"import_block","text":"","category":"section"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"The second argument to the macro is supposed to be either a single using/import statement, or multiple statements wrapped inside a begin...end block.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"These statements are used to select which parts of the loaded Package module have to be evaluated and which of its variables have te be imported within the notebook scope. Most of these import statements are only relevant when called within Pluto, so @frompackage simply avoid loading the target Package and deletes these import statements in most cases when called oustide of Pluto. There is a specific type of import statement (relative import) that is relevant and applicable also outside of Pluto, so this kind of statement is maintained in the macro output even outside of Pluto.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"The macro respects the differentiation between using and import as in normal Julia, so statements containing using Module without any variable name specifier will import all the exported names of Module.","category":"page"},{"location":"frompackage/basic_use/#Reload-Button","page":"Basic Use","title":"Reload Button","text":"","category":"section"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"When called within Pluto, the @frompackage macro also creates a convenient button that can be used to re-execute the cell calling the macro to reload the Package code due to a change in the source files.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"This button can also be used to quickly navigate to the position of the cell containing the macro by using Ctrl+Click.\nThe reload button will change appearance (getting a red border) when the macrocall incur in a runtime error either due to incorrect import statement (like if a relative import is used without a proper target) or due to an error encountered when loading the package code.","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"Here is a short video showing the reload button. The window on the left has opened the specific_imports1.jl notebook, while the one on the right has the specific_imports2.jl one. ","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"Both are included in the TestPackage using for tests and defined in test/TestPackage/src/TestPackage.jl","category":"page"},{"location":"frompackage/basic_use/","page":"Basic Use","title":"Basic Use","text":"<video controls=true>\n<source src=\"https://user-images.githubusercontent.com/12846528/236453634-c95aa7b2-61eb-492f-85f5-6539bbb714d5.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"frompackage/import_statements/#Supported-import-statements","page":"Supported import statements","title":"Supported import statements","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"The macro supports 4 different types of import statements:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"Relative Imports \nImports from the Package module\nImport from the Parent module (or submodule)\nImport from the Package dependencies (direct or indirect).","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"which are explained in more details in their respective section","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"All of them also allow the following (catch-all) notation import Module: *, which imports within the notebook all the variables that are created or imported within Module. This is useful when one wants to quickly import all the names defined in Module for testing without requiring to either:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"export all names in the definition of Module\nexplicitly import each name using the import Module: name1, name2, ... synthax","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"Each import statement can only contain one module, so statements like *import Module1, Module2 are not supported. In case multiple imports are *needed, use multiple statements within a begin...end block.","category":"page"},{"location":"frompackage/import_statements/#Relative-Imports","page":"Supported import statements","title":"Relative Imports","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"Relative imports are the ones where the module name starts with a dot (.). These are mostly relevant when the loaded module contains multiple submodules.\nRelative import statements are also produced when the macro is called from Pluto.","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"note: Note\nRelative imports are mostly useful when creating packages with notebooks as building blocks (i.e. notebooks that are included within the local package module)\n\nWhile catch-all notation is supported also with relative imports (e.g. import ..SiblingModule: *), the extraction of all the names from the desired relative module requires loading and inspecting the full Package module and is thus only functional inside of Pluto.\nA relative-import with catch-all notation is deleted when @frompackage is called outside of Pluto.","category":"page"},{"location":"frompackage/import_statements/#Imports-from-Package-module","page":"Supported import statements","title":"Imports from Package module","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"These are all the import statements that have the name PackageModule or ^ as the first identifier, e.g.: ","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"using PackageModule.SubModule \nimport PackageModule: varname \nimport PackageModule.SubModule.SubSubModule: * ","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"These statements are processed by the macro and transformed so that PackageModule actually points to the module that was loaded by the macro.","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"The alternative notation ^ can also be used to represent the PackageModule, so one can write the two expressions below interchangeably","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"@fromparent import PackageModule: var_name\n@fromparent import ^: var_name","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"This is to avoid triggering the Pkg statusmark within Pluto which always appears when a valid name of a package is typed (^ is not valid so it doesn't create the status mark). See image below: (Image: image)","category":"page"},{"location":"frompackage/import_statements/#Imports-from-Parent-module-(or-submodule)","page":"Supported import statements","title":"Imports from Parent module (or submodule)","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"These statements are similar to the previous (imports from Package module) ones, with two main difference:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"They only work if the target file is actually a file that is included in the loaded Package, giving an error otherwise\nParentModule does not point to the loaded Package, but the module that contains the line that calls include(target).","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"If target  is loaded from the Package main module, and not from one of its submodules, then ParentModule will point to the same module as PackageModule.","category":"page"},{"location":"frompackage/import_statements/#Catch-All","page":"Supported import statements","title":"Catch-All","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"A special kind parent module import is:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"import *","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"which is equivalent to:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"import ParentModule: * if the target file provided to @frompackage/@fromparent is a file included in the target Package. \nThis tries to reproduce within the namespace of the calling notebook, the namespace that would be visible by the notebook file when it is loaded as part of the Package module outside of Pluto.\nimport PackageModule: * if the target file provided to @frompackage/@fromparent is not a file included in the target Package. ","category":"page"},{"location":"frompackage/import_statements/#Imports-from-Package-dependencies","page":"Supported import statements","title":"Imports from Package dependencies","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"It is possible to to import direct (or indirect) dependencies of the target Package from within the @frompackage macro. Direct dependencies are the ones directy listed within the [deps] section of the Project.toml. Indirect dependencies are instead all the packages within the Package's Manifest.toml which are not direct dependencies. To import a package dependency from the @frompackage macro, one must prepend the package name with >., so for example if one wants to load the BenchmarkTools package from the macro, assuming that it is indeed a dependency of the target package, one can do:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"@frompackage target begin\n    using >.BenchmarkTools\nend","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"This modification is necessary when trying to use @frompackage in combination with the Pluto PkgManager, as explained in Issue 10.","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"These kind of statements (import/using from Dependencies) are also supported both inside and outside Pluto. Outside of Pluto, only direct dependencies are supported (as that is how julia works) which means that the example code above will effectively translate to using BenchmarkTools both inside and outside of Pluto if BenchmarkTools is a direct dependency.","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"note: Note\nThese kind of statements can not be used in combination with the catch-all imported name (*).\n\nImports from package dependencies are useful when trying to combine @frompackage with the integrated Pluto PkgManager. In this case, is preferable to keep in the Pluto notebook environment just the packages that are not also part of the target/loaded Package environment, and load the eventual packages that are also in the environment of the loaded Package directly from within the @frompackage import_block.\n\nDoing so minimizes the risk of having issues caused by versions collision between dependencies that are shared both by the notebook environment and the loaded Package environment. Combining the use of @frompackage with the Pluto PkgManager is a very experimental feature that comes with significant caveats.  Please read the related section at the end of this README","category":"page"},{"location":"frompackage/import_statements/#Re-export-using-names-with-Catch-All","page":"Supported import statements","title":"Re-export using names with Catch-All","text":"","category":"section"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"Prior to version v0.7.3 of PlutoDevMacros, the catch-all import would not allow to automatically import names in the scope of the parent/package module that were added via using statements. See Issue 11 for more details on the reasons.","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"This meant that to effectively have access to all of the names in the parent/package scope, the statement @fromparent import * would not be sufficient. If for example you had using Base64 at the top of your module, to effectively have access to also the names of the Base64 stdlib, you would have to call the macro as follows:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"@fromparent begin\n    import *\n    using >.Base64\nend","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"Since v0.8.0 of PlutoDevMacros, the automatic inclusion of names exposed via using statements is the default behavior when doing catch-all imports.","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"note: Note\nSince this behavior now brings by default many more names into scope, a new functionality in 0.8 is a check that names in the target packages do not clash with existing names in the Pluto module that is calling @frompackage. Once a clash is identified (i.e. two different objects with the same name are defined in both the Pluto module and the target package), the specific clashed name will not be brought into scope by @frompackage and a warning will be issued. \n\nYou can see this warning for example in the test notebook at test/TestUsingNames/test_notebook2.jl, where the name :clash_name is explicitly given to different values both in the target and calling modules, and results in the following warning: (Image: Warning Example Image)","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"If one wants to revert back to the previous version where only names effectively defined within the target module (or explicitly imported with import OtherPackage: x) would be brought into the Pluto module's scope, it is sufficient to prepend the @exclude_using macro to the catch-all import statement like so:","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"@fromparent @exclude_using import *","category":"page"},{"location":"frompackage/import_statements/","page":"Supported import statements","title":"Supported import statements","text":"This statement can be used alone or coupled with other valid import statements within a begin ... end block.","category":"page"},{"location":"#PlutoDevMacros","page":"Home","title":"PlutoDevMacros","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PlutoDevMacros.","category":"page"},{"location":"#@frompackage/@fromparent","page":"Home","title":"@frompackage/@fromparent","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"frompackage/introduction.md\",\n    \"frompackage/basic_use.md\",\n    \"frompackage/import_statements.md\",\n    \"frompackage/skipping_parts.md\",\n    \"frompackage/use_with_plutopkg.md\",\n    \"frompackage/package_extensions.md\",\n]\nDepth = 1","category":"page"},{"location":"frompackage/skipping_parts/#Skipping-Package-Parts","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"","category":"section"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The macro also allows to specify parts of the source code of the target Package that have to be skipped when loading it within Pluto. This is achieved by adding a statement inside the import_block like the following:","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"@skiplines lines","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The @skiplines macro is not defined within the package, it's just processed during the parsing of the @frompackage macro.","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"lines is expected to either be a single String, or a group of Strings within a begin ... end block. Each string represent a part of a file that has to be skipped, with the following formats being supported:","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"filpeath:::firstline-lastline: This specifies that all the lines between firstline and lastline (extrema included) in the file present at filepath must be skipped when loading the Package module\nfilepath:::line: Like 1. but a single line is skipped\nfilepath: Like 1. but the full file located at filepath is ignored when loading the module \nline: Ignores line number line in the Package entry point (i.e. the file at src/PackageName.jl in the folder of PackageName)\nfirstline-lastline: Like 4., but ignores a range of lines.","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"In all of the examples above filepath can be provided as either an absolute path, or as a relative path starting from the src subfolder of the Package folder","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The functionality of skipping lines is only used when @frompackage is called inside Pluto.  When calling the macro from outside of Pluto, the eventual statement with @skiplines is discarded.","category":"page"},{"location":"frompackage/skipping_parts/#Example","page":"Skipping Package Parts","title":"Example","text":"","category":"section"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"For an example consider the source file of the TestPackage module defined at test/TestPackage/src/TestPackage.jl, whose contents are shown below:","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"(Image: image)","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The notebook called out_notebook.jl located in the main folder of TestPackage gives an example of how to use the new functionality.","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The following call to @fromparent is used to import the TestPackage in the notebook's workspace while removing some of the code that is present in the original source of TestPackage:","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"@fromparent begin\n\timport TestPackage\n\t@skiplines begin\n\t\t\"11\" # Skip line 11 in the main file TestPackage.jl.\n\t\t\"test_macro2.jl\" # This skips the whole file test_macro2.jl\n\t\t\"22-23\" # This skips from line 21 to 22 in the main file, including extrema.\n\t\t\"test_macro1.jl:::28-10000\" # This skips parts of test_macro1.jl\n\tend\nend","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"The output of the notebook is also pasted here for reference:","category":"page"},{"location":"frompackage/skipping_parts/","page":"Skipping Package Parts","title":"Skipping Package Parts","text":"(Image: image)","category":"page"},{"location":"frompackage/use_with_plutopkg/#Use-with-PlutoPkg","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"","category":"section"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"The macro evaluates the code of the local target package within the Pluto notebook workspace. For this to work, the notebook needs to have access to all the packages that are loaded within the target package.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"Normally, this is achieved by either:","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"Adding the dependencies directly to the notebook environment\nActivating the environment of the local package within the notebook","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"The first option risk polluting the notebook environment with a lot of packages that are not directly used within the notebook, while the second option deactivate the integrate PlutoPkg which handles package dependencies.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"To address these issues, the macro currently adds the target package environment to the LOAD_PATH during package code evaluation in the notebook workspace.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"This approach gives the flexibility of loading arbitrary local package code without requiring to modify the notebook environment itself.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"note: Note\nFor this to work, the environment of the local target package needs to be instantiated. The macro will actually errors if this is not the case.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"The macro tries to catch all possible exceptions that are thrown either during macro compilation or during the resulting expression evaluation (using a try catch) to correctly clean LOAD_PATH after the macro is executed.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"This approach may cause issues in case the notebook and the package environment share some dependencies at different version. In this case, the one that was loaded first is the actual version used within the notebook (and within the Package module when loaded in the notebook).","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"The macro adds the local package environment at the second position in the LOAD_PATH (so after the notebook environment). This should minimize the potential issues as the notebook environment is parsed first to find the packages. This does not prevent the case when a package (for example DataFrames) that is only used by the loaded package, is also added to the notebook after the target Package has been loaded.  In this case, the version of DataFrames used by the notebook will be the version loaded by Package, and not the one installed in the notebook environment. Upon restarting the notebook, the situation will flip. Since now DataFrames is in the notebook environment, the notebook version will be loaded both in the notebook and in the Package module, potentially causing issues with the PackageCode if it was depending on a different version of DataFrames.","category":"page"},{"location":"frompackage/use_with_plutopkg/","page":"Use with PlutoPkg","title":"Use with PlutoPkg","text":"Due to the issues just mentioned, use the macro knowing that it might break if you want to use the Pluto PkgManager without manually adding all depending packages to the notebook environment.","category":"page"}]
}
